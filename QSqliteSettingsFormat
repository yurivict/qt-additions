#include <QSettings>
#include <QSet>
#include <QString>
#include <QStringList>
#include <QVariant>
#include <QByteArray>
#include <QIODevice>
#include <QDataStream>
#include <QTextStream>
#include <QSqlDatabase>
#include <QSqlQuery>
#include <QSqlError>
#include <QFile>
#include <QMapIterator>
//#include <QKeySequence>
#include <QDebug>
#ifndef QT_NO_GEOM_VARIANT
#include <QRect>
#include <QSize>
#include <QPoint>
#endif // !QT_NO_GEOM_VARIANT

//
// QSqliteSettingsFormat saves your app settings to the SQLite DB instead of the file
//

class QSqliteSettingsFormat {
private: // internals
  static QSqlDatabase& getDb(const QString &dbPath) {
    static QSqlDatabase db;
    if (!db.isOpen()) {
      db = QSqlDatabase::addDatabase("QSQLITE");
      db.setDatabaseName(dbPath);
      if (!db.open())
        dbError("open", db.lastError());
      // schema
      QSqlQuery query(db);
      if (!query.exec(
        "create table if not exists key_value "
          "(key varchar(1024) primary key,"
          " val_type integer not null,"
          " val_data text null)"))
        dbError("create table", db.lastError());
      if (!query.exec(
        "create table if not exists qt_version "
          "(version varchar(32) primary key)"))
        dbError("create table", db.lastError());
      if (!query.exec(QString("insert or ignore into qt_version (version) values ('%1')").arg(QT_VERSION_STR)))
        dbError("insert(qt_version)", db.lastError());
    }
    return db;
  }
  template<typename T>
  static QByteArray serialize(const T& x) {
    QByteArray ba;
    QDataStream s(&ba, QIODevice::WriteOnly);
    s << x;
    return ba;
  }
  template<typename T>
  static T unserialize(QByteArray ba) {
    QDataStream s(&ba, QIODevice::ReadOnly);
    T res;
    s >> res;
    return res;
  }
  static QString byteArrayToString(const QByteArray& ba) {
    QString res;
    QTextStream ts(&res);
    for (int i = 0; i<ba.size(); i++) {
      QString str;
      str.sprintf("%02x", (unsigned char)ba.at(i));
      ts << str;
    }
    return res;
  }
  static QByteArray stringToByteArray(const QString& str) {
    QByteArray ba;
    ba.resize(str.size()/2);
    char *data = ba.data();
    for (int i = 0; i < str.size(); i+=2)
      *data++ = (char)(hexToInt(str.at(i).toLatin1())*16 + hexToInt(str.at(i+1).toLatin1()));
    return ba;
  }
  static unsigned hexToInt(char hex) {return hex<='9' ? hex-'0' : (hex-'a' + 10);}
  static void writeMap(QSqlDatabase &db, const QSettings::SettingsMap &map) {
    QSet<QString> keysExist;
    {
      QSqlQuery qrySelect(db);
      if (!qrySelect.exec("select key from key_value"))
        dbError("select(key)", db.lastError());
      while (qrySelect.next())
        keysExist.insert(qrySelect.value(0).toString());
    }
    QSqlQuery qryInsert(db);
    QSqlQuery qryUpdate(db);
    qryInsert.prepare("insert into key_value(key, val_type, val_data) values (:key, :val_type, :val_data)");
    qryUpdate.prepare("update key_value set val_type = :val_type, val_data = :val_data where key = :key");
    QMapIterator<QString, QVariant> i(map);
    while (i.hasNext()) {
      i.next();
      QSqlQuery &qry = keysExist.contains(i.key()) ? qryUpdate : qryInsert;
      keysExist.erase(keysExist.find(i.key()));
      qry.bindValue(":key", i.key());
      QVariant v = i.value();
      qry.bindValue(":val_type", int(v.type()));
      switch (v.type()) {
        case QVariant::Invalid: {
          qry.bindValue(":val_data", QVariant(QVariant::String));
          break;
        }
        case QVariant::ByteArray: {
          qry.bindValue(":val_data", byteArrayToString(v.toByteArray()));
          break;
        }
        case QVariant::String:
        case QVariant::LongLong:
        case QVariant::ULongLong:
        case QVariant::Int:
        case QVariant::UInt:
        case QVariant::Bool:
        case QVariant::Double:
        case QVariant::KeySequence: {
          qry.bindValue(":val_data", v.toString());
          break;
        }
#ifndef QT_NO_GEOM_VARIANT
        case QVariant::Rect: {
          qry.bindValue(":val_data", byteArrayToString(serialize<QRect>(qvariant_cast<QRect>(v))));
          break;
        }
        case QVariant::Size: {
          qry.bindValue(":val_data", byteArrayToString(serialize<QSize>(qvariant_cast<QSize>(v))));
          break;
        }
        case QVariant::Point: {
          qry.bindValue(":val_data", byteArrayToString(serialize<QPoint>(qvariant_cast<QPoint>(v))));
          break;
        }
#endif // !QT_NO_GEOM_VARIANT
        default: {
#ifndef QT_NO_DATASTREAM
          QByteArray a;
          QDataStream s(&a, QIODevice::WriteOnly);
          s << v;
          qry.bindValue(":val_data", byteArrayToString(a));
#else
          Q_ASSERT(!"QSettings: Cannot save custom types without QDataStream support");
#endif
        }
      }
        
      if (!qry.exec())
        dbError(&qry==&qryInsert ? "insert" : "update", db.lastError());
    }

    if (!keysExist.empty()) {
      QSqlQuery qryDelete(db);
      qryDelete.prepare("delete from key_value where key = :key");
      QSetIterator<QString> i(keysExist);
      while (i.hasNext()) {
        qryDelete.bindValue(":key", i.next());
        if (!qryDelete.exec())
          dbError("delete", db.lastError());
      }
    }
  }
  static void readMap(QSqlDatabase &db, QSettings::SettingsMap &map) {
    QSqlQuery qrySelect(db);
    if (!qrySelect.exec("select key, val_type, val_data from key_value"))
      dbError("select", db.lastError());
    while (qrySelect.next()) {
      QString key = qrySelect.value(0).toString();
      QVariant::Type valType = (QVariant::Type)qrySelect.value(1).toInt();
      QString valString = qrySelect.value(2).toString();
      switch (valType) {
        case QVariant::Invalid: {
          map[key] = QVariant();
          break;
        }
        case QVariant::ByteArray: {
          map[key] = stringToByteArray(valString);
          break;
        }
        case QVariant::String: {
          map[key] = QVariant(valString);
          break;
        }
        case QVariant::LongLong: {
          map[key] = QVariant(valString.toLongLong());
          break;
        }
        case QVariant::ULongLong: {
          map[key] = QVariant(valString.toULongLong());
          break;
        }
        case QVariant::Int: {
          map[key] = QVariant(valString.toInt());
          break;
        }
        case QVariant::UInt: {
          map[key] = QVariant(valString.toUInt());
          break;
        }
        case QVariant::Bool: {
          map[key] = QVariant(valString=="true");
          break;
        }
        case QVariant::Double: {
          map[key] = QVariant(valString.toDouble());
          break;
        }
        //case QVariant::KeySequence: {
        //  map[key] = QVariant(QKeySequence::fromString(valString));
        //  break;
        //}
#ifndef QT_NO_GEOM_VARIANT
        case QVariant::Rect: {
          map[key] = QVariant(unserialize<QRect>(stringToByteArray(valString)));
          break;
        }
        case QVariant::Size: {
          map[key] = QVariant(unserialize<QSize>(stringToByteArray(valString)));
          break;
        }
        case QVariant::Point: {
          map[key] = QVariant(unserialize<QPoint>(stringToByteArray(valString)));
          break;
        }
#endif // !QT_NO_GEOM_VARIANT
        default: {
#ifndef QT_NO_DATASTREAM
          QByteArray ba = stringToByteArray(valString);
          QDataStream stream(&ba, QIODevice::ReadOnly);
          QVariant result;
          stream >> result;
          map[key] = result;
#else
          Q_ASSERT(!"QSettings: Cannot save custom types without QDataStream support");
#endif
        }
      }
    }
  }
  static QString deviceToFileName(QIODevice &device) {
    return ((QFile&)device).fileName();
  }
  static QString deviceToDbFile(QIODevice &device) {
    QStringList spl = deviceToFileName(device).split(".");
    spl[spl.size()-1] = "sqlite";
    return spl.join(".");
  }
  static void dbError(const char *op, const QSqlError &msg) {
    qDebug() << "SqliteSettings: database error occurred during '" << op << "': " << msg;
  }
public: // format interface for QSettings::registerFormat
  static bool readFile(QIODevice &device, QSettings::SettingsMap &map) {
    QSqlDatabase &db = getDb(deviceToDbFile(device));
    readMap(db, map);
    return true;
  }
  static bool writeFile(QIODevice &device, const QSettings::SettingsMap &map) {
    QSqlDatabase &db = getDb(deviceToDbFile(device));
    writeMap(db, map);
    // only the placeholder is written into the original config file
    device.write("placeholder");
    return true;
  }
}; // QSqliteSettingsFormat

